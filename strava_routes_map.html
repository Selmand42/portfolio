import os
from dotenv import load_dotenv
import requests
import folium
from folium.plugins import MarkerCluster
from polyline import decode

# Load environment variables
load_dotenv()

def get_strava_client():
    """Get a new access token using the refresh token."""
    client_id = os.getenv('STRAVA_CLIENT_ID')
    client_secret = os.getenv('STRAVA_CLIENT_SECRET')
    refresh_token = os.getenv('STRAVA_REFRESH_TOKEN')

    print(f"DEBUG: STRAVA_CLIENT_ID={client_id}")
    print(f"DEBUG: STRAVA_CLIENT_SECRET={client_secret}")
    print(f"DEBUG: STRAVA_REFRESH_TOKEN={refresh_token}")

    if not all([client_id, client_secret, refresh_token]):
        raise ValueError("Please set STRAVA_CLIENT_ID, STRAVA_CLIENT_SECRET, and STRAVA_REFRESH_TOKEN in .env file")

    # Get a new access token
    try:
        response = requests.post(
            'https://www.strava.com/oauth/token',
            data={
                'client_id': client_id,
                'client_secret': client_secret,
                'refresh_token': refresh_token,
                'grant_type': 'refresh_token'
            }
        )
        response.raise_for_status()  # Raise an exception for bad status codes
        data = response.json()
        return data['access_token']
    except requests.exceptions.RequestException as e:
        print(f"Error making request to Strava API: {str(e)}")
        if hasattr(e.response, 'text'):
            print(f"Response from Strava: {e.response.text}")
        raise
    except KeyError:
        print("Error: Access token not found in response")
        print(f"Response from Strava: {response.text}")
        raise

def fetch_routes(access_token):
    """Fetch all activities from Strava API."""
    headers = {
        'Authorization': f'Bearer {access_token}'
    }
    activities_url = 'https://www.strava.com/api/v3/athlete/activities'
    activities = []
    page = 1
    per_page = 100
    while True:
        params = {
            'per_page': per_page,
            'page': page
        }
        response = requests.get(activities_url, headers=headers, params=params)
        if response.status_code != 200:
            raise Exception(f"Failed to fetch activities: {response.text}")
        page_activities = response.json()
        print(f"Page {page} response: {page_activities}")  # Debug output
        if not page_activities:
            break
        activities.extend(page_activities)
        page += 1
        if len(page_activities) < per_page:
            break
    routes = []
    for activity in activities:
        if activity.get('map') and activity['map'].get('summary_polyline'):
            route = {
                'name': activity['name'],
                'type': activity['type'],
                'polyline': activity['map']['summary_polyline'],
                'distance': activity['distance'],
                'elevation': activity.get('total_elevation_gain', 0),
                'date': activity['start_date_local'][:10]
            }
            routes.append(route)
    print(f"Found {len(routes)} activities with routes")
    return routes

def get_activity_color(activity_type):
    """Return color and icon for different activity types."""
    colors = {
        'Run': 'red',
        'Ride': 'blue',
        'Swim': 'cyan',
        'Walk': 'green',
        'Hike': 'darkgreen',
        'AlpineSki': 'purple',
        'BackcountrySki': 'darkpurple',
        'Canoeing': 'orange',
        'Crossfit': 'pink',
        'EBikeRide': 'lightblue',
        'Elliptical': 'gray',
        'Golf': 'lightgreen',
        'Handcycle': 'darkred',
        'IceSkate': 'lightcyan',
        'InlineSkate': 'darkblue',
        'Kayaking': 'darkorange',
        'Kitesurf': 'lightpurple',
        'NordicSki': 'darkgray',
        'RockClimbing': 'brown',
        'RollerSki': 'lightgray',
        'Rowing': 'darkcyan',
        'Snowboard': 'darkpink',
        'Snowshoe': 'lightbrown',
        'StairStepper': 'darkgreen',
        'StandUpPaddling': 'lightorange',
        'Surfing': 'lightpink',
        'Velomobile': 'darkbrown',
        'WeightTraining': 'black',
        'Wheelchair': 'darkgray',
        'Yoga': 'lightgreen'
    }

    icons = {
        'Run': 'running',
        'Ride': 'bicycle',
        'Swim': 'swimmer',
        'Walk': 'walking',
        'Hike': 'hiking',
        'AlpineSki': 'skiing',
        'BackcountrySki': 'skiing',
        'Canoeing': 'water',
        'Crossfit': 'dumbbell',
        'EBikeRide': 'bicycle',
        'Elliptical': 'heartbeat',
        'Golf': 'golf-ball',
        'Handcycle': 'wheelchair',
        'IceSkate': 'skating',
        'InlineSkate': 'skating',
        'Kayaking': 'water',
        'Kitesurf': 'wind',
        'NordicSki': 'skiing',
        'RockClimbing': 'mountain',
        'RollerSki': 'skiing',
        'Rowing': 'water',
        'Snowboard': 'snowboarding',
        'Snowshoe': 'shoe-prints',
        'StairStepper': 'stairs',
        'StandUpPaddling': 'water',
        'Surfing': 'water',
        'Velomobile': 'bicycle',
        'WeightTraining': 'dumbbell',
        'Wheelchair': 'wheelchair',
        'Yoga': 'om'
    }

    return colors.get(activity_type, 'gray'), icons.get(activity_type, 'question')

def calculate_activity_stats(routes):
    """Calculate statistics for all activities."""
    stats = {
        'total_distance': 0,
        'total_elevation': 0,
        'activity_counts': {},
        'activity_distances': {},
        'activity_elevations': {}
    }

    for route in routes:
        # Convert distance from meters to kilometers
        distance_km = route['distance'] / 1000
        activity_type = route['type']

        # Update totals
        stats['total_distance'] += distance_km
        stats['total_elevation'] += route['elevation']

        # Update activity-specific stats
        if activity_type not in stats['activity_counts']:
            stats['activity_counts'][activity_type] = 0
            stats['activity_distances'][activity_type] = 0
            stats['activity_elevations'][activity_type] = 0

        stats['activity_counts'][activity_type] += 1
        stats['activity_distances'][activity_type] += distance_km
        stats['activity_elevations'][activity_type] += route['elevation']

    return stats

def create_stats_html(stats, position=None):
    """Create HTML for displaying activity statistics."""
    style = position or 'top: 50px; right: 50px; max-width: 320px; background: rgba(255,255,255,0.95); box-shadow: 0 2px 8px rgba(0,0,0,0.15); border-radius: 10px;'
    html = f'''
    <div style="position: fixed;
                {style}
                border:2px solid #888; z-index:9999;
                padding:14px;
                font-size:15px;
                max-height: 80vh;
                overflow-y: auto;
                ">
    <h3 style="margin-top: 0; color:#333;">Activity Statistics</h3>
    <p><strong>Total Distance:</strong> {stats['total_distance']:.2f} km</p>
    <p><strong>Total Elevation:</strong> {stats['total_elevation']:.0f} m</p>
    <hr>
    <h4 style="margin-bottom: 8px;">By Activity Type:</h4>
    '''
    # Sort activities by distance
    sorted_activities = sorted(
        stats['activity_distances'].items(),
        key=lambda x: x[1],
        reverse=True
    )
    for activity_type, distance in sorted_activities:
        count = stats['activity_counts'][activity_type]
        elevation = stats['activity_elevations'][activity_type]
        color, _ = get_activity_color(activity_type)
        html += f'''
        <div style="margin-bottom: 10px;">
            <p style="margin: 0;">
                <span style="color:{color}; font-size:18px;">‚óè</span> <strong>{activity_type}</strong>
            </p>
            <p style="margin: 5px 0 5px 20px;">
                Activities: {count}<br>
                Distance: {distance:.2f} km<br>
                Elevation: {elevation:.0f} m
            </p>
        </div>
        '''
    html += '</div>'
    return html

def create_route_map(routes):
    """Create a map with all routes."""
    if not routes:
        raise ValueError("No routes found to display")

    # Calculate statistics
    stats = calculate_activity_stats(routes)

    # Create a map centered on Istanbul with a closer zoom level
    m = folium.Map(
        location=[41.0082, 28.9784],  # Istanbul coordinates
        zoom_start=11,  # Decreased zoom level for a more zoomed out view
        tiles='OpenStreetMap',
        control_scale=True
    )

    # Add different tile layers
    folium.TileLayer('OpenStreetMap', name='OpenStreetMap').add_to(m)
    folium.TileLayer('Stamen Terrain', name='Terrain').add_to(m)
    folium.TileLayer('Stamen Toner', name='Toner').add_to(m)
    folium.TileLayer('CartoDB positron', name='Light').add_to(m)
    folium.TileLayer('CartoDB dark_matter', name='Dark').add_to(m)

    # Create feature groups for different activity types
    activity_groups = {}
    marker_clusters = {}

    # Add each route to the map
    for route in routes:
        # Decode polyline
        coordinates = decode(route['polyline'])

        # Get color and icon for activity type
        color, icon = get_activity_color(route['type'])

        # Create feature group for this activity type if it doesn't exist
        if route['type'] not in activity_groups:
            activity_groups[route['type']] = folium.FeatureGroup(name=f'{route["type"]} Routes').add_to(m)
            marker_clusters[route['type']] = MarkerCluster(name=f'{route["type"]} Start/End Points').add_to(m)

        # Create a popup with route information
        popup_text = f"""
        <b>{route['name']}</b><br>
        Type: {route['type']}<br>
        Date: {route['date']}<br>
        Distance: {route['distance']/1000:.2f} km<br>
        Elevation: {route['elevation']:.0f} m
        """

        # Add the route to the map with a bolder line and tooltip
        folium.PolyLine(
            coordinates,
            weight=5,
            color=color,
            opacity=0.85,
            popup=folium.Popup(popup_text, max_width=350),
            tooltip=f"{route['name']} ({route['type']}, {route['distance']/1000:.2f} km)"
        ).add_to(activity_groups[route['type']])

        # Add start point marker
        folium.Marker(
            coordinates[0],
            popup=f"Start: {route['name']}",
            tooltip=f"Start: {route['name']}",
            icon=folium.Icon(color='green', icon=icon, prefix='fa')
        ).add_to(marker_clusters[route['type']])

        # Add end point marker
        folium.Marker(
            coordinates[-1],
            popup=f"End: {route['name']}",
            tooltip=f"End: {route['name']}",
            icon=folium.Icon(color='red', icon=icon, prefix='fa')
        ).add_to(marker_clusters[route['type']])

    # Add layer control
    folium.LayerControl().add_to(m)

    # Add fullscreen option
    folium.plugins.Fullscreen().add_to(m)

    # Add minimap
    folium.plugins.MiniMap(toggle_display=True).add_to(m)

    # Add search functionality with custom positioning
    geocoder = folium.plugins.Geocoder()
    geocoder.add_to(m)
    m.get_root().header.add_child(folium.Element("""
        <style>
            .leaflet-control-geocoder {
                position: fixed !important;
                top: 10px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                z-index: 1000 !important;
            }
        </style>
    """))

    # Add statistics panel (move to top left, make less intrusive)
    m.get_root().html.add_child(folium.Element(
        create_stats_html(stats, position='left: 50px; top: 50px; max-width: 320px; background: rgba(255,255,255,0.95); box-shadow: 0 2px 8px rgba(0,0,0,0.15); border-radius: 10px;')
    ))

    return m

def main():
    try:
        # Get access token
        print("Getting access token...")
        access_token = get_strava_client()
        # Fetch routes
        print("Fetching routes...")
        routes = fetch_routes(access_token)
        if not routes:
            print("No activities with routes found for this athlete.")
            return
        # Create map
        print("Creating map...")
        m = create_route_map(routes)
        # Save map
        print("Saving map...")
        m.save('strava_routes_map.html')
        print("Map saved as 'strava_routes_map.html'")
    except Exception as e:
        print(f"An unexpected error occurred: {str(e)}")
        print("Full error details:")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
